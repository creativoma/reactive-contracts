import type { Contract, ShapeDefinition, TypeDefinition } from '@reactive-contracts/core';
import { writeFile, mkdir } from 'fs/promises';
import { dirname } from 'path';

/**
 * Generate TypeScript types for frontend
 */
export async function generateFrontendTypes(contract: Contract, outputPath: string): Promise<void> {
  const { definition } = contract;
  const typeName = definition.name;

  // Generate TypeScript type definitions
  const typeDefinitions = generateTypeDefinitions(definition.shape, `${typeName}Shape`);

  // Generate contract status types
  const content = `/**
 * Auto-generated types for ${typeName} contract
 * DO NOT EDIT - This file is generated by @reactive-contracts/compiler
 */

import type { ContractStatus } from '@reactive-contracts/core';

${typeDefinitions}

/**
 * Parameters for ${typeName} contract
 */
export interface ${typeName}Params {
  // Add your params here based on contract requirements
  [key: string]: unknown;
}

/**
 * Full result type for ${typeName} contract
 */
export interface ${typeName}Result {
  data: ${typeName}Shape;
  status: ContractStatus;
  metadata: {
    executionTime: number;
    cacheHit: boolean;
    derivedAt: 'client' | 'edge' | 'origin';
  };
}

/**
 * Contract intent: ${definition.intent}
 */
export const ${typeName}Intent = '${definition.intent}' as const;
`;

  // Ensure directory exists
  await mkdir(dirname(outputPath), { recursive: true });

  // Write to file
  await writeFile(outputPath, content, 'utf-8');
}

/**
 * Generate resolver template for backend
 */
export async function generateBackendResolver(
  contract: Contract,
  outputPath: string
): Promise<void> {
  const { definition } = contract;
  const typeName = definition.name;

  // Generate shape type
  const shapeType = generateTypeDefinitions(definition.shape, `${typeName}ResolverShape`);

  // Generate resolver template
  const content = `/**
 * Auto-generated resolver template for ${typeName} contract
 * Generated by @reactive-contracts/compiler
 *
 * Intent: ${definition.intent}
 */

import { implementContract } from '@reactive-contracts/server';
import type { Contract } from '@reactive-contracts/core';
import type { ResolverContext } from '@reactive-contracts/server';

${shapeType}

/**
 * Implement the ${typeName} contract resolver
 *
 * This function should return data matching the contract shape.
 * Derived fields will be computed automatically - don't include them.
 */
export const ${typeName}Resolver = implementContract(
  // Import your contract definition here
  {} as Contract, // Replace with your contract
  {
    async resolve(params: Record<string, unknown>, context: ResolverContext): Promise<${typeName}ResolverShape> {
      // TODO: Implement your data fetching logic here

      // Example:
      // const data = await db.query(...);
      // return {
      //   // Map your data to match the contract shape
      // };

      throw new Error('${typeName}Resolver not implemented yet');
    },

    // Optional: Configure caching
    cache: {
      ttl: '5m',
      staleWhileRevalidate: '1h',
      tags: (params) => [\`${typeName.toLowerCase()}:\${params.id}\`],
    },
  }
);
`;

  // Ensure directory exists
  await mkdir(dirname(outputPath), { recursive: true });

  // Write to file
  await writeFile(outputPath, content, 'utf-8');
}

/**
 * Generate runtime negotiator
 */
export async function generateRuntimeNegotiator(
  contract: Contract,
  outputPath: string
): Promise<void> {
  const { definition } = contract;
  const typeName = definition.name;

  const content = `/**
 * Auto-generated runtime negotiator for ${typeName} contract
 * DO NOT EDIT - This file is generated by @reactive-contracts/compiler
 */

import type { Contract } from '@reactive-contracts/core';

/**
 * Runtime negotiator for ${typeName}
 * Handles SLA monitoring, fallback logic, and performance tracking
 */
export class ${typeName}Negotiator {
  private contract: Contract;
  private metrics: {
    executionTime: number[];
    cacheHits: number;
    cacheMisses: number;
  } = {
    executionTime: [],
    cacheHits: 0,
    cacheMisses: 0,
  };

  constructor(contract: Contract) {
    this.contract = contract;
  }

  /**
   * Execute contract with SLA monitoring
   */
  async execute<TData>(
    resolver: () => Promise<TData>,
    options?: {
      useCache?: boolean;
      timeout?: number;
    }
  ): Promise<{
    data: TData;
    status: {
      latency: 'normal' | 'degraded' | 'violated';
      freshness: 'fresh' | 'stale' | 'expired';
      availability: 'available' | 'degraded' | 'unavailable';
    };
    metadata: {
      executionTime: number;
      cacheHit: boolean;
      derivedAt: 'client' | 'edge' | 'origin';
    };
  }> {
    const startTime = performance.now();

    try {
      // Execute resolver
      const data = await resolver();
      const executionTime = performance.now() - startTime;

      // Track metrics
      this.metrics.executionTime.push(executionTime);
      if (options?.useCache) {
        this.metrics.cacheHits++;
      } else {
        this.metrics.cacheMisses++;
      }

      // Determine latency status
      const maxLatency = this.getMaxLatency();
      const latencyStatus = this.evaluateLatency(executionTime, maxLatency);

      return {
        data,
        status: {
          latency: latencyStatus,
          freshness: 'fresh',
          availability: 'available',
        },
        metadata: {
          executionTime,
          cacheHit: options?.useCache ?? false,
          derivedAt: 'origin',
        },
      };
    } catch (error) {
      // Handle fallback based on contract constraints
      throw error;
    }
  }

  /**
   * Get metrics for monitoring
   */
  getMetrics() {
    const avgExecutionTime =
      this.metrics.executionTime.length > 0
        ? this.metrics.executionTime.reduce((a, b) => a + b, 0) / this.metrics.executionTime.length
        : 0;

    return {
      averageExecutionTime: avgExecutionTime,
      p95ExecutionTime: this.calculateP95(),
      cacheHitRate:
        this.metrics.cacheHits / (this.metrics.cacheHits + this.metrics.cacheMisses) || 0,
      totalExecutions: this.metrics.executionTime.length,
    };
  }

  private getMaxLatency(): number {
    const latency = this.contract.definition.constraints?.latency?.max;
    if (!latency) return Infinity;

    // Simple parsing for MVP
    const match = latency.match(/^(\\d+)(ms|s|m)$/);
    if (!match) return Infinity;

    const value = parseInt(match[1], 10);
    const unit = match[2];

    switch (unit) {
      case 'ms': return value;
      case 's': return value * 1000;
      case 'm': return value * 60 * 1000;
      default: return Infinity;
    }
  }

  private evaluateLatency(
    executionTime: number,
    maxLatency: number
  ): 'normal' | 'degraded' | 'violated' {
    if (executionTime <= maxLatency) {
      return 'normal';
    } else if (executionTime <= maxLatency * 1.5) {
      return 'degraded';
    } else {
      return 'violated';
    }
  }

  private calculateP95(): number {
    if (this.metrics.executionTime.length === 0) return 0;

    const sorted = [...this.metrics.executionTime].sort((a, b) => a - b);
    const index = Math.floor(sorted.length * 0.95);
    return sorted[index];
  }
}

/**
 * Create a new negotiator instance
 */
export function create${typeName}Negotiator(contract: Contract): ${typeName}Negotiator {
  return new ${typeName}Negotiator(contract);
}
`;

  // Ensure directory exists
  await mkdir(dirname(outputPath), { recursive: true });

  // Write to file
  await writeFile(outputPath, content, 'utf-8');
}

/**
 * Generate TypeScript type definitions from shape
 */
function generateTypeDefinitions(shape: ShapeDefinition, typeName: string): string {
  const fields = generateShapeFields(shape, 0);

  return `export interface ${typeName} {
${fields}
}`;
}

/**
 * Recursively generate shape fields
 */
function generateShapeFields(shape: ShapeDefinition, indent: number): string {
  const indentStr = '  '.repeat(indent + 1);
  const lines: string[] = [];

  for (const [key, value] of Object.entries(shape)) {
    const typeStr = generateTypeString(value, indent + 1);
    lines.push(`${indentStr}${key}: ${typeStr};`);
  }

  return lines.join('\n');
}

/**
 * Generate TypeScript type string from type definition
 */
function generateTypeString(type: TypeDefinition, indent: number): string {
  if (typeof type === 'string') {
    // Primitive or URL type
    switch (type) {
      case 'string':
        return 'string';
      case 'number':
        return 'number';
      case 'boolean':
        return 'boolean';
      case 'Date':
        return 'Date';
      case 'null':
        return 'null';
      case 'undefined':
        return 'undefined';
      default:
        if (type === 'URL' || type.startsWith('URL<')) {
          return 'string'; // URLs are represented as strings
        }
        return 'any';
    }
  } else if (typeof type === 'object' && type !== null) {
    // Check if it's a DerivedField
    if ('_brand' in type && type._brand === 'DerivedField') {
      // For derived fields, we don't know the return type at compile time
      // In a real implementation, we'd analyze the function
      return 'any';
    } else {
      // Nested shape
      const fields = generateShapeFields(type as ShapeDefinition, indent);
      const indentStr = '  '.repeat(indent);
      return `{\n${fields}\n${indentStr}}`;
    }
  }

  return 'any';
}
