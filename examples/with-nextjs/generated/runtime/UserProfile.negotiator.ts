/**
 * Auto-generated runtime negotiator for UserProfile contract
 * DO NOT EDIT - This file is generated by @reactive-contracts/compiler
 */

import type { Contract } from '@reactive-contracts/core';

/**
 * Runtime negotiator for UserProfile
 * Handles SLA monitoring, fallback logic, and performance tracking
 */
export class UserProfileNegotiator {
  private contract: Contract;
  private metrics: {
    executionTime: number[];
    cacheHits: number;
    cacheMisses: number;
  } = {
    executionTime: [],
    cacheHits: 0,
    cacheMisses: 0,
  };

  constructor(contract: Contract) {
    this.contract = contract;
  }

  /**
   * Execute contract with SLA monitoring
   */
  async execute<TData>(
    resolver: () => Promise<TData>,
    options?: {
      useCache?: boolean;
      timeout?: number;
    }
  ): Promise<{
    data: TData;
    status: {
      latency: 'normal' | 'degraded' | 'violated';
      freshness: 'fresh' | 'stale' | 'expired';
      availability: 'available' | 'degraded' | 'unavailable';
    };
    metadata: {
      executionTime: number;
      cacheHit: boolean;
      derivedAt: 'client' | 'edge' | 'origin';
    };
  }> {
    const startTime = performance.now();

    try {
      // Execute resolver
      const data = await resolver();
      const executionTime = performance.now() - startTime;

      // Track metrics
      this.metrics.executionTime.push(executionTime);
      if (options?.useCache) {
        this.metrics.cacheHits++;
      } else {
        this.metrics.cacheMisses++;
      }

      // Determine latency status
      const maxLatency = this.getMaxLatency();
      const latencyStatus = this.evaluateLatency(executionTime, maxLatency);

      return {
        data,
        status: {
          latency: latencyStatus,
          freshness: 'fresh',
          availability: 'available',
        },
        metadata: {
          executionTime,
          cacheHit: options?.useCache ?? false,
          derivedAt: 'origin',
        },
      };
    } catch (error) {
      // Handle fallback based on contract constraints
      throw error;
    }
  }

  /**
   * Get metrics for monitoring
   */
  getMetrics() {
    const avgExecutionTime =
      this.metrics.executionTime.length > 0
        ? this.metrics.executionTime.reduce((a, b) => a + b, 0) / this.metrics.executionTime.length
        : 0;

    return {
      averageExecutionTime: avgExecutionTime,
      p95ExecutionTime: this.calculateP95(),
      cacheHitRate:
        this.metrics.cacheHits / (this.metrics.cacheHits + this.metrics.cacheMisses) || 0,
      totalExecutions: this.metrics.executionTime.length,
    };
  }

  private getMaxLatency(): number {
    const latency = this.contract.definition.constraints?.latency?.max;
    if (!latency) return Infinity;

    // Simple parsing for MVP
    const match = latency.match(/^(\d+)(ms|s|m)$/);
    if (!match) return Infinity;

    const value = parseInt(match[1], 10);
    const unit = match[2];

    switch (unit) {
      case 'ms': return value;
      case 's': return value * 1000;
      case 'm': return value * 60 * 1000;
      default: return Infinity;
    }
  }

  private evaluateLatency(
    executionTime: number,
    maxLatency: number
  ): 'normal' | 'degraded' | 'violated' {
    if (executionTime <= maxLatency) {
      return 'normal';
    } else if (executionTime <= maxLatency * 1.5) {
      return 'degraded';
    } else {
      return 'violated';
    }
  }

  private calculateP95(): number {
    if (this.metrics.executionTime.length === 0) return 0;

    const sorted = [...this.metrics.executionTime].sort((a, b) => a - b);
    const index = Math.floor(sorted.length * 0.95);
    return sorted[index];
  }
}

/**
 * Create a new negotiator instance
 */
export function createUserProfileNegotiator(contract: Contract): UserProfileNegotiator {
  return new UserProfileNegotiator(contract);
}
